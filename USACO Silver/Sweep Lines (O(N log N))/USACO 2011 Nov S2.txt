Problem 2: Cow Lineup [Brian Dean]

Farmer John has hired a professional photographer to take a picture of some
of his cows.  Since FJ's cows represent a variety of different breeds, he
would like the photo to contain at least one cow from each distinct breed
present in his herd.

FJ's N cows are all standing at various positions along a line, each
described by an integer position (i.e., its x coordinate) as well as an
integer breed ID.  FJ plans to take a photograph of a contiguous range of
cows along the line.  The cost of this photograph is equal its size -- that
is, the difference between the maximum and minimum x coordinates of the
cows in the range of the photograph.  

Please help FJ by computing the minimum cost of a photograph in which there
is at least one cow of each distinct breed appearing in FJ's herd.

PROBLEM NAME: lineup

INPUT FORMAT:

* Line 1: The number of cows, N (1 <= N <= 50,000).

* Lines 2..1+N: Each line contains two space-separated positive
        integers specifying the x coordinate and breed ID of a single
        cow.  Both numbers are at most 1 billion.

SAMPLE INPUT (file lineup.in):

6
25 7
26 1
15 1
22 3
20 1
30 1

INPUT DETAILS:

There are 6 cows, at positions 25,26,15,22,20,30, with respective breed IDs
7,1,1,3,1,1.

OUTPUT FORMAT:

* Line 1: The smallest cost of a photograph containing each distinct
        breed ID.

SAMPLE OUTPUT (file lineup.out):

4

OUTPUT DETAILS:

The range from x=22 up through x=26 (of total size 4) contains each of the
distinct breed IDs 1, 3, and 7 represented in FJ's herd.

Solution Notes: This is a somewhat interesting problem since there are several nice algorithmic ways to approach its solution. The problem can be solved in O(N log N) time due to the need to sort the cows by x coordinate as a preprocessing step. One nice method (perhaps not the simplest, but worth mentioning) is the following: we sort scan through the cows from left to right (i.e., by x coordinate) keeping track of the most recent occurrence of each ID in a data structure. For example, if we are visiting a cow at (x,ID) = (10,17), our data structure might tell us that the most recent previous occurrence of a cow with breed ID 17 was at x=3, at which point we would then update the record in the data structure to x=10 and continue scanning (for IDs that have not yet occurred, we keep track of the value -infinity). Now as we scan over a particular coordinate x, let us suppose x is the right endpoint of a photograph window; we can compute the best possible matching left endpoint by simply taking the minimum of all the "most recent occurrence" x values in our data structure, so if we use an appropriate data structure like a heap, we can determine this minimum very quickly, making the entire scan take only O(N log N) time. During the scan, we simply remember the largest window we have seen.

A slightly simpler approach involves scanning both the left and right endpoint of the photograph window in a monotonic fashion in lock step. We start with left = right = the leftmost cow. We then advance the right pointer whenever we notice that not every type of breed ID is present in the window; otherwise we advance the left pointer (noting the size of the window in this case, so we can return the largest over the entire scan). We can tell whether every breed ID exists within our window by storing a count of each breed ID within the window in a data structure like a map or multiset (or even a simple array would work, if we first sort the IDs and then map them down to integers in the range 0...N-1 as a preprocessing step). The breed ID counts are incremented whenever we advance the right pointer and decremented whenever we advance the left pointer.



#include <stdio.h>
#include <stdlib.h>
#include <map>
#include <set>
using namespace std;

typedef struct {
  int loc, id;
} Cow;

int sort_cows(const void* v1, const void *v2) {
  Cow *c1 = (Cow*)v1, *c2 = (Cow*)v2;
  return c1->loc>c2->loc;
}

int main() {
  freopen("lineup.in", "r", stdin); freopen("lineup.out", "w", stdout);
  int num_IDS, N, i, num_in_map = 0, A[50000], IDS[50000], start, end, min;
  Cow cows[50000];
  map<int, int> breeds;
  set<int> ID_set;

  scanf("%d", &N);
  for(i=0; i<N; i++) {
    scanf("%d %d", &cows[i].loc, &cows[i].id);
    ID_set.insert(cows[i].id);
    breeds[cows[i].id] = 0;
  }

  qsort(cows, N, sizeof(Cow), sort_cows);

  num_IDS = ID_set.size();

  start = 0;
  end = 0;
  min = 1<<30;

  while(1) {
    while(num_in_map!=num_IDS && end<N) {
      if(breeds[cows[end].id]==0)
        num_in_map++;
      breeds[cows[end++].id]++;
    }
    if(end==N && num_in_map!=num_IDS)
      break;

    while(breeds[cows[start].id]>1)
      breeds[cows[start++].id]--;

    if(cows[end-1].loc-cows[start].loc<min) min = cows[end-1].loc-cows[start].loc;
    breeds[cows[start++].id]--;
    num_in_map--;
  }

  printf("%d\n", min);

  return 0;
}